# <i>Group Documentation <i/>

# Group Members:

- Lena Aschauer 
- Amadeo Noels 
- Luthando Mashigo 
- Josias Hoffman
 
 
# Week 1 

## 7/11

### The kit - table
 
This the <a href= https://docs.google.com/document/d/1s6Q4YwDniuX3-o7bFId8eT2VyiTMTn_2Ks8KojxuRqM/edit >link <a/> to our table which staes all the devices. 
 
## 9/11

### IoT Architecture

IoT Architecture:

<img src="Images/IoTArchitecture.jpg" width=450 height=450/><br/>

Server: It is a Data Integration Controller equipped with a highly reliable industrial computer and non-programming data integration software. It is capable of collecting, processing, storing, reporting, and publishing data through standard data management functions developed.

Nodes: The main two features of an IoT node are to manage the interconnection between the hardware and the rest of the network and to recollect the information generated by itself. In other words, the IoT nodes are the elements within an IoT ecosystem that allow the connection of the physical world with the Internet.

Gateway: An IoT gateway is a centralized hub that connects IoT devices and sensors to cloud-based computing and data processing. IoT gateways are designed to simplify and streamline IoT device communications and management.

Cloud: Cloud computing is a platform where one can view a computer, storage and network infrastructure as an abstract entity. This allows us to deploy systems quickly and scale easily. Very important here is thinking of self-service. Which means that users can get started via filling out a Web form.

Things: A thing, in the context of the Internet of things (IoT), is an entity or physical object that has a unique identifier, an embedded system and the ability to transfer data over a network.

Edge: This is about processing, analyzing and storing data close to where it is generated to enable easy real-time analysis and response.

Swarm: Swarm Intelligence systems are decentralized, self-organized algorithms used to resolve complex problems with dynamic properties, incomplete information, and limited computation capabilities. Swarm Intelligence can enable a collection of multiple IoT devices to work together and exchange information, thereby achieving greater utility.

Fog: This refers to a layer located between the cloud and the edge. Fog is in the ability to capture information from the edge layer before it reaches the cloud. This aims to decide which driven information is relevant and which is not. This allows the relevant data to be stored in the cloud while the unnecessary information can be removed.




# Week 2

## 14/11

### IOT Integration task :

We are getting the RFID Reader wemos d1 flashed. The Wemos d1 that will be used for the RFID scanner is flashed however we tried to research on how to send data of what the RFID reader is receiving via MQTT.  Still didn’t work but because our RFID reader is actual damaged in a matter we do not understand, and we tested with another teams RFID reader and the program actual works. The lecturer tried to re soldered er the RFID reader, but it failed, and the RFID reader does not work. We are now trying to connect the relay to a female wemos but the wemos was incorrectly soldered so we are using a different one. We are now getting the relay and lock to work.  We have configured the relay to function with the lock so that we could send mqtt messages from node red and receive them on the programmed wemos d1 mini with the topic Relay_Shield/Lock/set as shown in the screen shot.

<img src="Images/Integration4Hardware.jpeg" width=250 height=250/>

<img src="Images/RelayNodeRed.png" width=500 height=250/>

What would happen when we flip the switch in node red it would send an on signal to the topic and then the lock would respond by either locking or unlocking.
 
Here is our setup.cpp file for the lock and relay as shown in the image below.

<img src="Images/SetupimageRelay.png" width=500 height=250/>

We are building the rest of the integration with the traffic light and the rfid senor works and are able to send data via MQTT and be able to build logic to have the lights of the traffic light switch on based on certain conditions such as turning the light red for access denied and turning green for having the right key card.  We wired the traffic light incorrectly by putting the red into ground instead of D2. However regardless the red light constantly remained on  but we are rewiring the traffic light hardware to a female wemos. We plugged the wire meant for green into the yellow pin. We got the traffic light working and there will be images to display how the works. We are now re integrating the lock and relay and we are testing using previous complied logic. We used the wrong pin output for the logic and now it works. Our topic now was incorrect. So, we had to use D1 instead of D2 since the data line in the relay is connected to D1. 

We now trying to now integrate the buzzer and we have to use another wemos and are flashing using the PI for the initial. We are looking into the documentation. When access is granted, the buzzer does make a sound. So Lastly we have the flow that made the program function as best as it.

Please find all the images blow of the hardware implementation.

<img src="Images/Integration1Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration2Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration3Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration5Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration6Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration7Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration8Hardware.jpeg" width=250 height=250/><br/>

<img src="Images/Integration1Hardware.jpeg" width=250 height=250/><br/>

Also please find the node red flow for the entire implementation.

<img src="Images/noderedintegrationnode3.png" width=700 height=250/>

## 17/11

# Checkout, compile and install SNode.C and the MQTTBrkoer on the Rasperry-PI

install on the raspberry pi

- installeren van de dependencies met volgend commando: sudo apt install doxygen iwyu clang-format cmake-format libmagic-dev libbackward-cpp-dev libdw-dev libdwarf-dev binutils-dev librange-v3-dev libssl-dev libeasyloggingpp-dev libbluetooth-dev nlohmann-json3-dev : in de iot-system folder

compiling snodec:

<ul> 
 <li> aanmaken van een folder: iotprojs</li>
<li> daarin nieuwe map: snodec</li>
<li> installeren van git</li>
<li> clone van de repository: https://github.com/VolkerChristian/snode.c</li>
<li> aanmaken nieuwe folder: mqttbroker</li>
<li> clone van de repository:</li>  <li> https://github.com/VolkerChristian/mqttbroker</li>
<li> terug naar snodec</li>
<li> nieuwe folder aanmaken build</li>
<li> commando: cmake ../snode.c/ => zoeken naar Clist <=></li>
<li> commando: make -j 16 (threads) => compiling snode</li>
<li> build directory => sudo make install</li>
 
</ul>

installeren mqtbroker:
installeren mqtcreator:

# Week 3
 
## 21/11/2022

***create an mqqtbrokerwebserver application*** <br>

create new directory => mqqtwebfrontend <br>
right click -> add new -> General -> Empty File -> chose -> name the file -> CMakeLists.txt<br>
copy existing CmakeLists.txt to the new CMakeLists.txt -> only adapt the parts that need to be adapted<br>
CMakeLists.txt<br>
--> line 51 & 53 : rename variable to mqttwebfrontend<br>
--> line 57 : rename variable to mqttwebfrontend<br>
--> line 60 : change targetname to mqqtwebfrontend<br>
--> line 65 : change name to mqqtwebfrontend <br>
--> line 73 : change broker to mqqtwebfrontend<br>
--> line 77 : change to mqttwebfrontend<br>

copy mqttbroker folder content:<br>
--> cpp && h copy (5) them to the mqqtwebfrontend<br>

binary directory /usr/local/bin <br>

--> integrate directory in the whole project <br>

--> root CMakeLists.txt file <br>
add_subdirectory mqttwebfrontend<br>

mqttbroker (main) -> set it as active project <br>

rename mqttbroker.cpp in mqttwebfrontend directory<br>
 --> right click --> Rename --> mqttwebfrontend.cpp<br>

**add webfunctionality**<br>

--> go to snode.c in the filesystem <br>
 source directory ==> src/apps/testpost.cpp<br>
split screen : right side split view<br>

**implement webfrontend**<br>

--> create unencryped <br><br>
add an include (express/legacy/in ...)<br>

copy express line and past it at the end of the line just before "return core:SNodeC::start();<br>
 --> rename legacy to mqttWebView<br>
 --> als server instance to mqttwebview<br>
 
 error thrown : during link fase <br>
  --> we didn't link the webfrontend application to a library <br>
  --> !!! needed for the webfrontendapplication<br>
 
 add library : <br>
  --> CMakeLists.txt (first one) --> find package() src/apps/CMakeLists.txt -> http-server-express<br>
 
 add it in the find package<br>
 
 mqttwebfrontend --> add library --> target_link_libraries<br>
 
 mqttwebfrontend.cpp --> add functionality -->  mqttWebView.listen() -> copy mqttlistenLegancyServer to the mqttWebView.listen()<br>
 
 test the build : directory --> ./mqttwebfrontend --> error legacyin is required --> ./mqttwebfrontend legacyin local --port 1883 tlsin  local --port 8883 legacyun local --path /tmp/mqttwebfrontend mqttwebview local --port 8080 -w<br>
 
the command : ./mqttwebfrontend can now be used because there is a config file present<br>

in the file mqttwebfrontend.cpp: <br>
 --> mqttWebView.get("/test", [] APPLICATION(req, res){<br>
 VLOG(0) << "#############" << "Here we are" << req.originalUrl;<br>
 res.send("Response FROM MQTTWebView");<br>
 });<br>
 
 mqttfrontend --> right click --> add new  --> c/c++ --> c++ Class --> specify name ('MqttModel')<br><br><br>
 line 51 --> add MqttModel.cpp<br><br>
 line 53 --> add MqttModel.h<br>
 
 **build application**
 
 file MqttModel.h<br>
 include 'iot/mqtt/packets/Connect.h'<br>
 --> private : add MqttModel()<br>
 --> public : <br>
    --> static MqttModel & instance(); --> righ click -> refacor -> add definiation MqttModel.cpp<br>
    --> void addConnectedClient(iot::mqtt::packets::Connect& connect); -> right click -> refactor<br>
 
 MqttModel&MqttModel::create(){<br>
 static MqttModel mqttModel;<br>
 --> static means only one time created  <br>
 return mqttModel;<br>
 }<br>
 
 in the file SocketContext.h:<br>
 
 add includ 'iot/mqtt/server/broker/Broker.h'<br>
 
 --> private : <br>
    --> void onConnect(iot::mqtt::packets::Connect& connect) override{<br>
      --> connectionList.push_back(connect);<br>
      }<br>
    --> void onPlublish(iot::mqtt::packets::Publish& publish) override;<br>
    
 refactor fase <br>
 
 onConnect method:<br>
    --> MqttModel::instance().addConnectedClient(connect);<br>
    
 implement method addConnectedClient<br>
 
 in the file MqttModel.h<br>
 
 add include <list><br>
 
 --> public<br>
    --> const std::list<iot::mqtt::packets::Connect>& getConnectedClients();<br>
 
 --> protected:<br>
    --> std::list<iot::mqtt::packets::Connect> connectionList;<br>
 
 in the file MqqtModel.cpp :<br>
 
 --> const std::list<iot::mqtt::packets::Connect>& MqttModel::getConnectedClients(){<br>
 return connectionList;<br>
 }<br>
 
 in the file mqttwebfrontend.cpp<br>
 
 --> mqttWebView.get("/clients", [] APPLICATION(req, res){<br>
 const std::list<iot::mqtt:packets::Connect>& connectList = MqttModel::instance().getConnectedClients();<br>
 MqttModel::instance().getConnectedClients();<br>
 std::string responseString;<br>
 
 for(const iot::mqtt:packets::Connect& connection : connectionList){<br>
  connection.getClientId();<br>
 });<br>
 
 res.send(responseString);<br>
 });<br>
 
 --> header file is missing <br>
 
 --> add an include 'MqttModel.h<br>
 
 
 <img src="images/Code_example.jpg" alt="drawing" width="500"/> <br>
 
## 23/11/2022

### We have to stop mqtt boot to not being started during boot.<br> ##
-> have to edit the iot>lib>system_boot>raspi-boot.sh file on the rpi. <br>
delete: <br>
new-window -d -n MQTT<br>
su- $IOTEMPOWER_USER -c 'echo iot exec mqtt broker' <br>
new-window -d -n cloudcm <br>
su - $IOTEMPOWER_USER -c 'echo iot exec cloudmd_starter'<br>

command cd .local/bin <br>
command ./nodered_starter <br>
command ps -aef | grep node-red <br>
command node-red <br>
command mqttbroker

## 24/11

### Tutorial : Create Root-CA, Endcertificate, Use these Certificates to secure the communication between mqttbroker and the mosquitto_sub/pub task : 

We installed XCA which is a certificate management software and was instructed to make a root certificate and a client and server certificate. We along with our groupmates explored the architecture/system of how certificates work. 

<img src="Images/CertificatesDiagram.png" width=650 height=350/>

We are also learning how to actually create the certificate within our local linux subsystems and not via the raspberry pi for tutorial purposes.

<img src="Images/CreationofRootCA.png" width=250 height=250/>

We are creating a certificate which will be a root CA certificate and defining its basic characteristics

<img src="Images/RootCACertificateSpecifics.png" width=350 height=350/>

We are always generating a new key for each certificate we make. 

<img src="Images/KeyGenerationRootCA.png" width=350 height=350/>

More definition we are giving to the Root CA

<img src="Images/ExtraDefeinitionRootCA.png" width=450 height=450/>

We also selected the key usage for the Root Certrificate

<img src="Images/RootCAKeyUsage.png" width=450 height=550/>

Summary of the details of the root CA

<img src="Images/RootCACertificateSummary.png" width=350 height=350/>

Now we are going to create to end certificates for web application purposes , A MQTT Server Certificate and a MQTT Client Certifcate to be specific.

This is my MQTT Server Certificate Summary 

<img src="Images/MQTTServerCertificateSummary.png" width=450 height=350/>
 
MQTT Client Certificate Summary 
 
<img src="Images/MQTTClientCertificateSummary.png" width=450 height=350/>

We are show two scenarios with an httpserver and the interactions with the certificates.
We are exporting the root CA using the PEM format 
We are also exporting the end entity certificate (Server and Client) but we a different method which is the pem chain which has all certificates upto the root. 
 
<img src="Images/CertificateSavedFolder.png" width=550 height=350/>

We also need to export the keys to unlock the certificates.
We export with encryption because then it is password encrypted.
 
<img src="Images/KeysSavedFolder.png" width=550 height=350/> 

We are configure the mqtt broker to work , server with the certificates but the lectuere is busy with that.

### Project Implementation:

We also did part of the project implementation with some assistance such as wiring the two esp8266’s with the temperature and scale.
 
<img src="Images/Project1Hardware.jpeg" width=450 height=450/><br/>

<img src="Images/Project2Hardware.jpeg" width=450 height=450/>

Also, We worked as a  team to get node red running and have the mqtt topics configured as shown in the node red screen shot. We had to make use of the IOTEmpower framework as we had no framework of our own.

<img src="Images/ProjCodeImplementation1.png" width=450 height=450/>
 
Also, along my team we flashed the two esp’s with code that would have us read the temperature , humidity and weight of the scale and pass that to node-red as shown in the setup.cpp files shown below.

<img src="Images/ProjCodeImplemntation4.png" width=450 height=450/><br/>

<img src="Images/ProjCodeImplemntation5.png" width=450 height=450/>
  
Lastly After the flashing and after receiving data we were able to pass data using these topics and having the program running and then having a temporary node-red UI as a stand in for front end display the data. I just quickly put that together since there was not enough time to fill flesh out the system.

<img src="Images/ProjCodeImplemntation3.png" width=450 height=450/><br/>

<img src="Images/ProjCodeImplemntation2.png" width=450 height=450/>


